#!/bin/sh
set -e

print_completion() { sort -u | $VIS_MENU | sed "s/^$1//" | tr -d '\n'; }
usage() { echo "usage: $(basename "$0") [-l lines] [-p prompt] [--word|--file] [pattern]"; }

VIS_MENU='vis-menu -b'
FIND_FILES_LIMIT=1000
FIND_MAXDEPTH=3       # 4 levels - expanding "$1"* will give us another level
COMPLETE_MODE='-'     # "-" standard input; "w" word; "f" filename

while [ $# -gt 0 ]; do
	case "$1" in
		-h|--help) usage 1>&2; exit 0
		           ;;
		-l|-p)     VIS_MENU="$VIS_MENU $1 $2"; shift
		           ;;
		--word)    COMPLETE_MODE='w'
		           ;;
		--file)    COMPLETE_MODE='f'
		           ;;
		*)         break
	esac
	shift
done

case $COMPLETE_MODE in
	-)
		# In this case  we can't predict what  kind of pattern will be  used. So let's
		# escape both slashes and meta-characters to avoid problems with sed and grep.
		PATTERN=$(printf '%s' "$1" | sed 's|[/\\.*^$[]|\\&|g')

		grep "^$PATTERN." | print_completion "$PATTERN"
		;;
	w)
		tr -cs '[:alnum:]_' '\n' | grep "^$1." | print_completion "$1"
		;;
	f)
		# Ignore hidden paths, unless pattern's "basename" starts with ".".
		case "$(basename "$1")" in ([!.]*) FIND_PRUNE='.*'; esac

		find "$1"* \
			-maxdepth $FIND_MAXDEPTH \
			-name "${FIND_PRUNE-.git}" -prune \
			-o -print 2> /dev/null |
			head -n $FIND_FILES_LIMIT |
			sed "s|^$(dirname "$1.")/||" |
			print_completion "$(basename "$1")"
		;;
esac
